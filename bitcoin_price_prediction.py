# -*- coding: utf-8 -*-
"""Bitcoin_Price-Prediction.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dL-zvMAvp4BKpcWnPeZBPNusbqYe0PCS

# Bitcoin Price Predictive Analytics

## 1. Import Library
"""

# Commented out IPython magic to ensure Python compatibility.
# Library untuk processing and visualization
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
import seaborn as sns
import os
import zipfile
# %matplotlib inline

# Library untuk preprocessing
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import MinMaxScaler

# Library untuk model XGBoost dan hyperparameter tuning
import xgboost as xgb
from sklearn.model_selection import GridSearchCV

# Library untuk evaluasi model
from sklearn.metrics import mean_squared_error
from sklearn.metrics import mean_absolute_error

# Untuk mengabaikan warning yang tidak penting
import warnings
warnings.filterwarnings('ignore')

"""## 2. Loading Data

Dataset yang digunakan didapatkan dari kaggle dengan rentang waktu dari 13 April 2013 - 7 Juli 2021 dan dari coinmarketcap dari 8 Juli 2021 - 19 Oktober 2024. Nantinya akan dilakukan preprocessing dan merge dari kedua dataset tersebut

### Dataset Kaggle
"""

!kaggle datasets download -d sudalairajkumar/cryptocurrencypricehistory

with zipfile.ZipFile("cryptocurrencypricehistory.zip", 'r') as zip_ref:
    zip_ref.extractall("crypto_data")

os.listdir("crypto_data")

btc_kg_df = pd.read_csv("/content/crypto_data/coin_Bitcoin.csv")
print('Shape of Kaggle Bitcoin dataset: ',btc_kg_df.shape)

btc_kg_df

"""Output kode di atas memberikan informasi sebagai berikut:
- Dataset berjumlah 2991 baris (records)
- Terdapat 10 kolom yaitu SNo, Name, Symbol, Date, High, Low, Open, Close, Volume, dan Marketcap.

### Dataset CoinMarketCap
"""

def clean_and_merge_datasets(file_paths):
    dataframes = []

    for file in file_paths:
        df = pd.read_csv(file, sep=';')
        df['timestamp'] = pd.to_datetime(df['timestamp'])

        dataframes.append(df)

    merged_df = pd.concat(dataframes, ignore_index=True)
    merged_df = merged_df.sort_values(by='timestamp', ascending=True)
    merged_df.reset_index(drop=True, inplace=True)

    def format_price(value):
        return f'{value:.6f}'

    price_columns = ['open', 'high', 'low', 'close']
    merged_df[price_columns] = merged_df[price_columns].applymap(format_price)

    merged_df['volume'] = merged_df['volume'].apply(lambda x: f'{x:.6e}')
    merged_df['marketCap'] = merged_df['marketCap'].apply(lambda x: f'{x:.6e}')

    return merged_df

file_paths = [
    '/content/Bitcoin_7_7_2021-12_31_2021_historical_data_coinmarketcap.csv',
    '/content/Bitcoin_12_31_2021-12_31_2022_historical_data_coinmarketcap.csv',
    '/content/Bitcoin_12_31_2022-12_31_2023_historical_data_coinmarketcap.csv',
    '/content/Bitcoin_12_31_2023-10_20_2024_historical_data_coinmarketcap.csv'
]

cmk_df = clean_and_merge_datasets(file_paths)

print('Shape of CoinMarketCap Bitcoin dataset: ',cmk_df.shape)
cmk_df

"""Output kode di atas memberikan informasi sebagai berikut:

Dataset berjumlah 1200 baris (records)
Terdapat 12 kolom yaitu timeOpen, timeClose, timeHigh, timeLow, name, open, high, low, close, volume, marketCap, timestamp.

## 3. Exploratory Data Analysis

### Mengupas Informasi Dataset
"""

btc_kg_df.info()

"""Berdasarkan informasi di atas, dataset memiliki beberapa kriteria sebagai berikut:
- 6 Kolom dengan tipe float64 yaitu High, Low, Open, Close, Volume, dan Marketcap
- 1 Kolom dengan tipe int64 yaitu SNo
- 3 Kolom dengan tipe object yaitu Name, Symbol, dan Date
"""

cmk_df.info()

"""Berdasarkan informasi di atas, dataset memiliki beberapa kriteria sebagai berikut:
- 10 Kolom dengan tipe object yaitu timeOpen, timeClose, timeHigh, timeLow, open, high, low, close, volume, marketCap
- 1 Kolom dengan tipe datetime[ns, UTC] yaitu timestamp
- 1 Kolom dengan tipe int64 yaitu name
"""

btc_kg_df.describe()

cmk_df.describe()

"""Fungsi describe() di atas memberi informasi statistik pada masing-masing kolom di kedua dataset, antara lain:

- Count adalah jumlah sampel pada data
- Mean adalah nilai rata-rata
- Std adalah standar deviasi
- Min yaitu nilai minimum setiap kolom
- 25% adalah kuartil pertama, Kuartil adalah nilai yang menandai batas interval dalam empat bagian sebaran yang sama.
- 50% adalah kuartil kedua, atau biasa juga disebut median
- 75% adalah kuartil ketiga
- Max adalah nilai maksimum
"""

btc_kg_df.isna().sum()

cmk_df.isna().sum()

"""Berdasarkan kode di atas, kedua dataset tidak memiliki missing value.

<br>

### Merge Dataset

Sebelum masuk ke visualisasi data, akan dilakukan merging terlebih dahulu pada kedua dataset dan hanya akan menggunakan kolom date, high, low, open, close, volume, dan marketcap dari masing masing dataset, selain dari itu akan dihapus karena tidak relevan dengan pengembangan model. Nama kolom di kedua dataset juga akan diubah menjadi lower case serta dengan urutan yang sama.


"""

btc_kg_df.drop(columns=['SNo', 'Name', 'Symbol'], inplace=True)
btc_kg_df.columns = btc_kg_df.columns.str.lower()

btc_kg_df

cmk_df.columns = cmk_df.columns.str.lower()
cmk_df.drop(['timeopen', 'timeclose', 'name', 'timehigh', 'timelow'], axis=1, inplace=True)

cmk_df['timestamp'] = cmk_df['timestamp'].dt.strftime('%Y-%m-%d %H:%M:%S')
cmk_df.rename(columns={'timestamp': 'date'}, inplace=True)

cmk_df = cmk_df[['date', 'high', 'low', 'open', 'close', 'volume', 'marketcap']]

"""Untuk dataset dari coinmarketcap, karena kolom timeOpen, timeClose, timeHigh, timeLow, dan timestamp terjadi di 1 periode waktu yang sama yaitu dalam rentang 24 jam, maka hanya kolom timestamp yang akan digunakan untuk menggambarkan waktu dan disesuaikan formatnya seperti kolom 'date' di dataset kaggle."""

cmk_df

btc_kg_df.info()

cmk_df.info()

"""Nampak bahwa tipe data untuk kolom high, low, open, close, volume, dan marketcap berbeda di kedua dataset, maka dari itu disamakan terlebih dahulu sebelum dimerge."""

cols_to_convert = ['high', 'low', 'open', 'close', 'volume', 'marketcap']
cmk_df[cols_to_convert] = cmk_df[cols_to_convert].astype(float)

cmk_df.info()

# Menggabungkan kedua dataframe
mrg_df = pd.concat([btc_kg_df, cmk_df], ignore_index=True)
mrg_df.sort_values(by='date', ascending=True, inplace=True)
mrg_df.reset_index(drop=True, inplace=True)

print('Shape of merged dataset: ',mrg_df.shape)
mrg_df

"""Setelah dataset kaggle dan coinmarketcap dimerge, didapatkan total 4191 baris (records) dengan 7 kolom yaitu date, high, low, open, close, volume, dan marketcap."""

mrg_df.info()

"""Berdasarkan informasi di atas, dataset memiliki beberapa kriteria sebagai berikut:
- 6 Kolom dengan tipe float64 yaitu high, low, open, close, volume, dan marketcap
- 1 Kolom dengan tipe object yaitu date

### Tren Pergerakan Harga Bitcoin
"""

# Mengubah kolom 'date' ke format datetime untuk mengurutkan dataset berdasarkan date
mrg_df['date'] = pd.to_datetime(mrg_df['date'])
mrg_df.sort_values(by='date', inplace=True)

plt.figure(figsize=(14, 6))

plt.plot(mrg_df['date'], mrg_df['open'], label='Opening Price', color='green', alpha=0.6)
plt.plot(mrg_df['date'], mrg_df['close'], label='Closing Price', color='red', alpha=0.6)
plt.plot(mrg_df['date'], mrg_df['high'], label='Highest Price', color='orange', alpha=0.6)
plt.plot(mrg_df['date'], mrg_df['low'], label='Lowest Price', color='blue', alpha=0.6)

plt.title('Analisis Pergerakan Harga Bitcoin')
plt.xlabel('Date')
plt.ylabel('Price (USD)')
plt.legend()
plt.grid(True)
plt.show()

"""Dari visualisasi di atas nampak beberapa informasi di antaranya:
- **Tren Keseluruhan**: Terlihat adanya tren peningkatan harga Bitcoin secara umum selama periode tersebut.
- **Volatilitas**: Terdapat periode fluktuasi harga yang signifikan, menunjukkan volatilitas yang tinggi. Misalnya, peningkatan dan penurunan harga yang tajam dapat diamati pada rentang waktu tertentu, seperti di tahun 2021.
- **Hubungan antar harga**: Harga pembukaan, penutupan, tertinggi, dan terendah cenderung bergerak bersama-sama, yang mengindikasikan adanya korelasi antara berbagai aspek aktivitas harga harian Bitcoin.

### Volatilitas Perubahan Harga
Volatilitas adalah ukuran statistik yang menggambarkan tingkat perubahan atau fluktuasi harga suatu aset dalam periode waktu tertentu. Dalam konteks Bitcoin, volatilitas sering digunakan untuk mengukur risiko atau ketidakstabilan harga dari waktu ke waktu.

Untuk menghitung volatilitas harga Bitcoin, berikut langkah-langkahnya:
1. Perubahan Persentase Harga (Return): Perubahan harga harian dihitung menggunakan percentage change atau persentase perubahan harga penutupan dari satu hari ke hari berikutnya:

  \begin{equation}
  {P_t} = \frac{C_t - C_{t-1}}{C_{t-1}}
  \end{equation}

  Di mana:

  \begin{aligned}
  P_t & = \text{Return harian pada hari } t, \; \textit{persentase perubahan harga penutupan.}\\[10pt]
  C_t & = \text{Harga penutupan pada hari } t, \; \textit{harga Bitcoin di akhir hari perdagangan.}\\[10pt]
  C_{t-1} & = \text{Harga penutupan pada hari } t-1, \; \textit{harga Bitcoin di akhir hari sebelumnya.}
  \end{aligned}


2. Standar Deviasi dari Return: Untuk mengukur volatilitas, diperlukan menghitung standar deviasi dari return harian. Standar deviasi mengukur seberapa jauh perubahan harga harian bervariasi dari nilai rata-ratanya. Semakin besar standar deviasi, semakin tinggi volatilitas harga Bitcoin.

  \begin{equation}
  {\sigma} = \sqrt{\frac{1}{N-1} \sum_{i=1}^{N} (R_i - \bar{R})^2}
  \end{equation}

  Di mana:

  \begin{aligned}
  \sigma & = \text{Standar deviasi dari return, mengukur volatilitas harga.}\\[10pt]
  N & = \text{Jumlah total observasi return (hari).}\\[10pt]
  R_i & = \text{Return harian pada hari ke-} i, \; \textit{perubahan persentase harga.}\\[10pt]
  \bar{R} & = \text{Rata-rata return harian, memberikan nilai tengah dari semua return.}
  \end{aligned}


3. Penyesuaian ke Periode Tertentu (Misalnya Mingguan, Bulanan): Untuk mengukur volatilitas dalam rentang waktu tertentu, misalnya mingguan atau bulanan, standar deviasi harian disesuaikan dengan mengalikan akar kuadrat dari jumlah hari dalam periode tersebut:

  \begin{equation}
  \text{Volatilitas Periodik} = \sigma \times \sqrt{T}
  \end{equation}

  Di mana:

  \begin{aligned}
  \text{Volatilitas Periodik} & = \text{Mengukur volatilitas dalam periode tertentu (mingguan, bulanan).}\\[10pt]
  \sigma & = \text{Standar deviasi dari return harian, menggambarkan volatilitas harian.}\\[10pt]
  T & = \text{Jumlah hari dalam periode yang dianalisis (contoh: 7 untuk mingguan, 30 untuk bulanan).}
  \end{aligned}

Secara keseluruhan, volatilitas memberikan gambaran seberapa besar perubahan harga Bitcoin dan membantu dalam memahami tingkat risiko dari fluktuasi harganya.

<br>

#### Jangka Pendek (7 Hari)
"""

mrg_df['Volatilitas Mingguan'] = mrg_df['close'].pct_change().rolling(window=7).std() * np.sqrt(7)

plt.figure(figsize=(14, 6))
plt.plot(mrg_df['date'], mrg_df['Volatilitas Mingguan'], label='Volatilitas 7H', color='orange')
plt.title('Volatilitas Perubahan Harga Bitcoin (7 Hari)')
plt.xlabel('Date')
plt.ylabel('Volatilitas')
plt.legend()
plt.grid(True)
plt.show()

"""#### Jangka Menengah (30 Hari)"""

mrg_df['Volatilitas Bulanan'] = mrg_df['close'].pct_change().rolling(window=30).std() * np.sqrt(30)

plt.figure(figsize=(14, 6))
plt.plot(mrg_df['date'], mrg_df['Volatilitas Bulanan'], label='Volatilitas 30H', color='Purple')
plt.title('Volatilitas Perubahan Harga Bitcoin (30 Hari)')
plt.xlabel('Date')
plt.ylabel('Volatilitas')
plt.legend()
plt.grid(True)
plt.show()

"""#### Jangka Panjang (90 Hari)"""

mrg_df['Volatilitas Jangka Panjang'] = mrg_df['close'].pct_change().rolling(window=90).std() * np.sqrt(90)

plt.figure(figsize=(14, 6))
plt.plot(mrg_df['date'], mrg_df['Volatilitas Jangka Panjang'], label='Volatilitas 90H', color='Red')
plt.title('Volatilitas Perubahan Harga Bitcoin (90 Hari)')
plt.xlabel('Date')
plt.ylabel('Volatilitas')
plt.legend()
plt.grid(True)
plt.show()

"""Dari ketiga visualisasi tingkat volatilitas harga Bitcoin tersebut didapatkan beberapa informasi di antaranya:
- Volatilitas Tinggi pada 2013-2014 dan 2017-2018: Terlihat lonjakan volatilitas yang signifikan pada periode tersebut, mengindikasikan fluktuasi harga Bitcoin yang besar. Periode tersebut bertepatan dengan bubble dan koreksi harga Bitcoin
- Volatilitas Menurun seiring Waktu: Secara umum, volatilitas Bitcoin cenderung menurun seiring waktu, meskipun masih terdapat periode dengan volatilitas tinggi
- Volatilitas Jangka Panjang lebih Stabil: Volatilitas 90 hari (jangka panjang) cenderung lebih stabil dibandingkan dengan volatilitas mingguan dan bulanan. Hal ini menunjukkan bahwa fluktuasi harga Bitcoin cenderung mereda dalam jangka waktu yang lebih panjang

### Rata-Rata Pergerakan Harga

Rata-rata Pergerakan Sederhana (Simple Moving Average - SMA) adalah metode perataan data harga dalam periode waktu tertentu untuk membantu mengidentifikasi tren dalam harga aset, seperti Bitcoin.

Perhitungan SMA dilakukan dengan cara mengambil rata-rata harga penutupan aset selama sejumlah hari tertentu, kemudian menggeser (rolling) jendela waktu tersebut setiap harinya untuk mendapatkan nilai SMA terbaru. Dengan cara ini, fluktuasi harga harian dapat dihaluskan sehingga tren harga lebih mudah dianalisis.

**Perhitungan SMA**

\begin{equation}
\text{SMA}n = \frac{C_t + C{t-1} + C_{t-2} + \dots + C_{t-n+1}}{n}
\end{equation}

Di mana:

\begin{aligned}
\text{SMA}_n & = \text{Simple Moving Average untuk periode } n \text{ hari.} \\[10pt]
C_t & = \text{Harga penutupan pada hari ke-} t.\\[10pt]
n & = \text{Jumlah hari dalam periode perhitungan SMA.}
\end{aligned}

Untuk SMA jangka pendek - menengah akan digunakan periode 50 hari, sedangkan untuk jangka panjang akan digunakan periode 200 hari.

**Mengapa 50 dan 200 Hari?**
- SMA-50 sering digunakan untuk mengukur tren jangka pendek hingga menengah. Periode 50 hari dianggap cukup untuk menunjukkan fluktuasi harga terbaru tanpa terlalu banyak "noise" dari pergerakan harga harian

- SMA-200 adalah indikator yang lebih umum digunakan untuk melihat tren jangka panjang. Periode ini cukup panjang untuk memberikan gambaran stabil tentang pergerakan harga dan menghilangkan fluktuasi harian yang tidak signifikan
"""

mrg_df['SMA-50'] = mrg_df['close'].rolling(window=50).mean()
mrg_df['SMA-200'] = mrg_df['close'].rolling(window=200).mean()

plt.figure(figsize=(14, 6))
plt.plot(mrg_df['date'], mrg_df['close'], label='Closing Price', color='red', alpha=0.6)

plt.plot(mrg_df['date'], mrg_df['SMA-50'], label='50 hari SMA', color='blue', alpha=0.6)
plt.plot(mrg_df['date'], mrg_df['SMA-200'], label='200 hari SMA', color='green', alpha=0.6)

plt.title('Pergerakan Harga Bitcoin dan SMA')
plt.xlabel('Date')
plt.ylabel('Price (USD)')
plt.legend()
plt.grid(True)
plt.show()

"""Dari visualasi di atas, didapatkan informasi sebagai berikut:

SMA-200 bertindak sebagai support (level harga di mana tren penurunan cenderung berhenti) dalam jangka panjang, sedangkan SMA-50 bertindak sebagai support dan resistance (level harga di mana tren kenaikan cenderung berhenti) dalam jangka pendek dan menengah.

- Golden Cross: Ketika SMA-50 memotong SMA-200 dari bawah ke atas, ini menandakan potensi dimulainya tren kenaikan harga (bullish)
- Death Cross: Ketika SMA-50 memotong SMA-200 dari atas ke bawah, ini menandakan potensi dimulainya tren penurunan harga (bearish)

## Korelasi antara Harga Penutupan dengan Volume Transaksi
"""

plt.figure(figsize=(14, 6))
plt.scatter(mrg_df['close'], mrg_df['volume'], alpha=0.5, color='blue')
plt.title('Korelasi antara Harga Penutupan dan Volume Transaksi')
plt.xlabel('Harga Penutupan')
plt.ylabel('Volume Transaksi')
plt.grid(True)
plt.show()

mrg_df['Korelasi Bergilir (30 Hari)'] = mrg_df['close'].rolling(window=30).corr(mrg_df['volume'])

plt.figure(figsize=(14, 6))
plt.plot(mrg_df['date'], mrg_df['Korelasi Bergilir (30 Hari)'], label='Korelasi Bergilir (30H)', color='orange')
plt.title('Pergerakan Korelasi Harga Penutupan dan Volume Transaksi (30 Hari)')
plt.xlabel('Tanggal')
plt.ylabel('Korelasi')
plt.legend()
plt.grid(True)
plt.show()

# Menghitung korelasi harga penutupan dan volume
corl = mrg_df['close'].corr(mrg_df['volume'])
print(f'\nNilai Korelasi antara Harga Penutupan dan Volume Transaksi: {corl:.2f}')

"""Dari kedua visualisasi di atas an hasil perhitungan korelasi, didapatkan informasi sebagai berikut:
- Sebaran titik-titik pada scatter plot menunjukkan adanya ketidaklinearan dalam hubungan antara harga dan volume. Titik-titik tidak membentuk pola garis lurus yang jelas, mengindikasikan faktor-faktor lain mungkin memengaruhi volume selain dari harga, seperti sentimen pasar, berita, dan regulasi, juga dapat memengaruhi volume transaksi Bitcoin dan perlu dipertimbangkan dalam analisis yang lebih komprehensif
- Meskipun umumnya positif, korelasi antara harga penutupan dan volume transaksi tidak selalu konsisten, ditunjukkan oleh fluktuasi pada grafik korelasi bergilir. Terdapat periode di mana korelasi melemah atau bahkan berbalik arah
- Nilai korelasi 0.67 menunjukkan hubungan yang cukup kuat, namun ketidaklinearan pada scatter plot mengingatkan kita bahwa korelasi tidak selalu berarti hubungan sebab-akibat yang sederhana

Setelah visualisasi selesai, kolom-kolom yang sudah tidak diperlukan seperti Volatilitas Mingguan, Volatilitas Bulanan, Volatilitas Jangka Panjang, SMA-50, SMA-200, Korelasi Bergilir (30 Hari) akan dihapus.
"""

mrg_df.drop(['Volatilitas Mingguan', 'Volatilitas Bulanan', 'Volatilitas Jangka Panjang', 'SMA-50', 'SMA-200', 'Korelasi Bergilir (30 Hari)'], axis=1, inplace=True)

"""## 4. Data Preparation

Pada bagian ini akan dilakukan beberapa persiapan data yaitu:

### 4.1. Membagi Feature dan Target serta Shifting Data
Dalam rangka memprediksi harga Bitcoin untuk 5 hari ke depan, langkah pertama adalah membagi feature dan target. Numerical feature yang digunakan terdiri dari kolom high, low, open, close, volume, dan marketcap. Target merupakan prediksi harga penutupan (closing price) Bitcoin pada hari ke-5 setelah data pada hari yang sedang diproses. Untuk menetapkan kolom target ini, digunakan teknik shifting, di mana data harga penutupan bergeser sebanyak 5 hari ke depan.
"""

# Menambahkan kolom target prediksi 5 hari ke depan
mrg_df['Prediction_5D'] = mrg_df['close'].shift(-5)

mrg_df

"""Setelah itu, fitur numerik perlu dimundurkan 5 hari agar selaras dengan target prediksi. Hal ini dilakukan untuk memastikan bahwa model menggunakan data dari 5 hari sebelumnya sebagai dasar prediksi harga di masa depan."""

mrg_df['high_shifted'] = mrg_df['high'].shift(5)
mrg_df['low_shifted'] = mrg_df['low'].shift(5)
mrg_df['open_shifted'] = mrg_df['open'].shift(5)
mrg_df['volume_shifted'] = mrg_df['volume'].shift(5)
mrg_df['marketcap_shifted'] = mrg_df['marketcap'].shift(5)

mrg_df.dropna(subset=['high_shifted', 'low_shifted', 'open_shifted', 'volume_shifted', 'marketcap_shifted', 'Prediction_5D'], inplace=True)
mrg_df[['high_shifted', 'low_shifted', 'open_shifted', 'volume_shifted', 'marketcap_shifted', 'Prediction_5D']].isna().sum()

# Menampilkan dataframe hasil shifting
shifted_df = mrg_df[['high_shifted', 'low_shifted', 'open_shifted', 'volume_shifted', 'marketcap_shifted', 'Prediction_5D']]

shifted_df

"""Pemunduran fitur ini penting untuk mencegah kebocoran data, di mana model dapat "melihat" informasi dari masa depan yang seharusnya belum tersedia. Pendekatan ini sesuai dengan prinsip dalam analisis time series, di mana variabel input (fitur) harus mencerminkan periode waktu sebelum variabel target. Setelah dilakukan pemunduran data dan menghapus nilai null, kini terdapat total 4,181 baris data yang siap untuk digunakan dalam model.

### 4.2 Split Dataset
"""

X = mrg_df[['high_shifted', 'low_shifted', 'open_shifted', 'volume_shifted', 'marketcap_shifted']]
y = mrg_df['Prediction_5D']

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

print("X_train shape:", X_train.shape)
print("X_test shape:", X_test.shape)
print("y_train shape:", y_train.shape)
print("y_test shape:", y_test.shape)

"""## 5. Model Development

Pada tahap ini menggunakan algoritma machine learning XGBoost dengan menerapkan hyperparameter tuning untuk mencari nilai learning rate, max_depth, subsample, dan n_estimators terbaik.

Model yang sudah dilatih akan dievaluasi dengan metrik MAE dan MSE.
<br>
"""

# Normalisasi fitur
scaler_X = MinMaxScaler()
X_train_scaled = scaler_X.fit_transform(X_train)
X_test_scaled = scaler_X.transform(X_test)

# Normalisasi variabel target
scaler_y = MinMaxScaler()
y_train_scaled = scaler_y.fit_transform(y_train.values.reshape(-1, 1))
y_test_scaled = scaler_y.transform(y_test.values.reshape(-1, 1))

xgb_model = xgb.XGBRegressor()
xgb_model.fit(X_train_scaled, y_train_scaled)

y_xgb_pred_scaled = xgb_model.predict(X_test_scaled)

y_xgb_pred = scaler_y.inverse_transform(y_xgb_pred_scaled.reshape(-1, 1))

xgb_mse = mean_squared_error(y_test, y_xgb_pred)
xgb_mae = mean_absolute_error(y_test, y_xgb_pred)

print(f'Mean Squared Error: {xgb_mse:.2f}')
print(f'Mean Absolute Error: {xgb_mae:.2f}')

"""Dari informasi di atas, didapatkan Mean Squared Error (MSE) sebesar 6.978.760.79 dan Mean Absolute Error (MAE) sebesar 1.242.54, yang menggambarkan tingkat kesalahan prediksi dalam model ini. Dengan MAE sebesar 1.242.54, ini berarti rata-rata prediksi harga Bitcoin meleset sekitar 1.242 USD dari harga sebenarnya. Mengingat volatilitas harga Bitcoin yang tinggi, kesalahan ini masih dalam batas wajar, terutama jika mempertimbangkan bahwa fluktuasi harga BTC bisa mencapai ribuan dolar dalam satu hari.

Namun, MSE yang lebih tinggi menunjukkan adanya outlier atau prediksi dengan kesalahan yang lebih besar. Untuk meningkatkan akurasi model dan mengurangi kesalahan prediksi, langkah selanjutnya adalah melakukan hyperparameter tuning.

### Hyperparameter Tuning

Hyperparameter tuning adalah sebuah proses untuk melakukan optimalisasi parameter pada sebuah model. Untuk proyek ini Parameter yang di gunakan ada 4 yaitu :

- learning_rate: Mengontrol tingkat di mana model belajar dari setiap iterasi. Nilai yang terlalu besar dapat menyebabkan overfitting, sedangkan nilai yang terlalu kecil dapat memperlambat konvergensi.
- max_depth: Mengontrol kedalaman maksimum pohon keputusan. Nilai yang terlalu besar dapat menyebabkan overfitting, sedangkan nilai yang terlalu kecil dapat menghambat kemampuan model untuk menangkap pola yang kompleks.
- subsample: Mengontrol proporsi data yang digunakan untuk membangun setiap pohon keputusan. Subsampling dapat membantu mengurangi overfitting.
- n_estimators: Menentukan jumlah pohon keputusan yang akan dibangun. Jumlah pohon yang terlalu sedikit dapat menyebabkan underfitting, sedangkan jumlah pohon yang terlalu banyak dapat menyebabkan overfitting.

Proses hyperparameter tuning akan dilakukan menggunakan teknik Grid Search yang bertujuan untuk melakukan validasi untuk lebih dari satu model dan hyperparameter masing-masing secara otomatis dan sistematis.
"""

param_grid = {
    'max_depth': [3, 5, 7],
    'learning_rate': [0.01, 0.1, 0.2],
    'n_estimators': [100, 200, 300],
    'subsample': [0.8, 1.0]
}

grid_search = GridSearchCV(estimator=xgb.XGBRegressor(), param_grid=param_grid, cv=5, scoring='neg_mean_squared_error')
grid_search.fit(X_train_scaled, y_train_scaled)

best_params = grid_search.best_params_
print(f'Best Parameters: {best_params}')

"""Berdasarkan informasi di atas, algoritma XGBoost memperoleh parameter terbaik yaitu learning_rate = 0.1, max_depth = 5, n_estimators = 100, dan subsample = 1.0"""

xgb_best_model = xgb.XGBRegressor(**best_params)
xgb_best_model.fit(X_train_scaled, y_train_scaled)

y_best_pred_scaled = xgb_best_model.predict(X_test_scaled)

y_best_pred = scaler_y.inverse_transform(y_best_pred_scaled.reshape(-1, 1))
best_mse= mean_squared_error(y_test, y_best_pred)
best_mae= mean_absolute_error(y_test, y_best_pred)

print(f'Mean Squared Error (tuning): {best_mse:.2f}')
print(f'Mean Absolute Error (tuning): {best_mae:.2f}')

"""Nilai akurasi model meningkat setelah diterapkan hyperparameter tuning dengan perolehan nilai Mean Squared Error: 6.450.337.21 dan Mean Absolute Error: 1.222.15. Tentunya performa model lebih baik jika dibandingkan dengan akurasi sebelum dilakukan tuning.

## 6. Model Evaluation
Seperti yang telah dijelaskan sebelumnya, metrik evaluasi yang digunakan adalah Mean Absolute Error (MAE) dan Mean Square Error (MSE).

**Kenapa MAE dan MSE?**
<br>
MAE dan MSE adalah dua metrik yang umum digunakan untuk mengukur kinerja model regresi, termasuk model XGBoost. Keduanya mengukur seberapa jauh prediksi model dari nilai sebenarnya, namun dengan cara yang sedikit berbeda.

- Mean Absolute Error (MAE)

  MAE adalah metrik yang mengukur rata-rata selisih absolut antara nilai prediksi model dengan nilai aktual. Dengan kata lain, MAE menghitung rata-rata dari nilai absolut perbedaan antara nilai yang diprediksi oleh model dengan nilai sebenarnya. Nilai MAE yang lebih kecil menunjukkan bahwa model semakin akurat dalam membuat prediksi.
  
  MAE memiliki keunggulan karena lebih robust terhadap outlier dibandingkan dengan MSE. Artinya, nilai outlier tidak akan terlalu memengaruhi nilai MAE secara signifikan.
  
  MAE sering digunakan ketika kita ingin mendapatkan gambaran umum tentang seberapa besar kesalahan model secara rata-rata

  \begin{equation}
  \text{MAE} = \frac{1}{n} \sum_{i=1}^{n} |y_i - \hat{y}_i|
  \end{equation}

  Di mana:

  \begin{aligned}
  \text{MAE} & = \text{Mean Absolute Error} \\[10pt]
  n & = \text{Jumlah data observasi} \\[10pt]
  y_i & = \text{Nilai aktual ke-} i \\[10pt]
  \hat{y}_i & = \text{Nilai prediksi ke-} i
  \end{aligned}

- Mean Squared Error (MSE)

  MSE adalah metrik lain yang populer untuk mengukur kinerja model regresi. MSE menghitung rata-rata kuadrat dari selisih antara nilai prediksi dan nilai aktual.
  
  Dengan mengkuadratkan selisih, MSE memberikan bobot yang lebih besar pada kesalahan yang besar. Ini berarti bahwa model akan lebih "dihukum" jika membuat prediksi yang jauh dari nilai sebenarnya.
  
  MSE sering digunakan ketika kita ingin memberikan penalti yang lebih besar pada kesalahan yang besar, karena kesalahan yang besar dapat memiliki konsekuensi yang lebih signifikan.

  \begin{equation}
  \text{MSE} = \frac{1}{n} \sum_{i=1}^{n} (y_i - \hat{y}_i)^2
  \end{equation}

  Di mana:

  \begin{aligned}
  \text{MSE} & = \text{Mean Squared Error} \\[10pt]
  n & = \text{Jumlah data observasi} \\[10pt]
  y_i & = \text{Nilai aktual ke-} i \\[10pt]
  \hat{y}_i & = \text{Nilai prediksi ke-} i
  \end{aligned}

### Perbandingan Performa dengan Baseline
"""

print(f'Mean Squared Error: {xgb_mse:.2f}')
print(f'Mean Absolute Error: {xgb_mae:.2f}')

"""Pada tahap awal, model dilatih tanpa melakukan hyperparameter tuning, menghasilkan nilai Mean Squared Error (MSE) sebesar 6.978.760,79 dan Mean Absolute Error (MAE) sebesar 1.242,54. Hasil ini menunjukkan bahwa model sudah cukup baik dalam memprediksi harga, namun masih terdapat ruang untuk perbaikan dalam hal akurasi prediksi."""

print(f'Mean Squared Error (tuning): {best_mse:.2f}')
print(f'Mean Absolute Error (tuning): {best_mae:.2f}')

"""Setelah melakukan tuning, model mengalami peningkatan performa dengan MSE menurun menjadi 6.450.337,21 dan MAE turun menjadi 1.222,15. Penurunan ini menunjukkan bahwa model mampu lebih baik dalam menyesuaikan hyperparameter untuk mengurangi kesalahan prediksi.

### Harga Aktual vs Prediksi

Dalam analisis ini, kita akan membandingkan harga aktual Bitcoin dengan harga yang diprediksi oleh model XGBoost melalui visualisasi scatterplot. Visualisasi ini tidak hanya memungkinkan kita untuk melihat sejauh mana prediksi model sejalan dengan data aktual, tetapi juga membantu kita mengidentifikasi pola dan outlier yang mungkin ada.
"""

y_best_pred_scaled = xgb_best_model.predict(X_test_scaled)
y_best_pred = scaler_y.inverse_transform(y_best_pred_scaled.reshape(-1, 1))

comparison_df = pd.DataFrame({'Aktual': y_test, 'Prediksi': y_best_pred.flatten()})

plt.figure(figsize=(14, 6))
sns.scatterplot(x=comparison_df['Aktual'], y=comparison_df['Prediksi'], alpha=0.6, label='Prediksi')
plt.plot([comparison_df['Aktual'].min(), comparison_df['Aktual'].max()],
         [comparison_df['Aktual'].min(), comparison_df['Aktual'].max()],
         color='red', linestyle='--', label='Garis Ideal')
plt.title('Harga Aktual vs Prediksi', fontsize=14)
plt.xlabel('Harga Aktual (USD)', fontsize=12)
plt.ylabel('Harga Prediksi (USD)', fontsize=12)
plt.grid()
plt.legend(loc='upper left')
plt.show()

"""Dari visualiasi di atas didapatkan informasi sebagai berikut:

- Meskipun ada beberapa titik data yang melenceng dari garis ideal, tetapi secara keseluruhan sebaran titik-titik pada grafik harga aktual vs harga prediksi menunjukkan bahwa prediksi model XGBoost cukup akurat dan mengikuti tren harga aktual dengan baik.

- Namun, perlu diingat bahwa model tetap memiliki keterbatasan dan prediksi harga Bitcoin di dunia nyata dipengaruhi oleh banyak faktor kompleks yang mungkin tidak sepenuhnya tercakup dalam model, seperti sentimen pasar, regulasi pemerintah, dan berita terkait Bitcoin.

### Prediksi Harga 5 Hari ke Depan
"""

last_features = mrg_df[['high_shifted', 'low_shifted', 'open_shifted', 'volume_shifted', 'marketcap_shifted']].iloc[-5:]
last_features_scaled = scaler_X.transform(last_features)

pred_xgb_scaled = xgb_best_model.predict(last_features_scaled)
pred_xgb = scaler_y.inverse_transform(pred_xgb_scaled.reshape(-1, 1))

last_date = pd.to_datetime('2024-10-19')

predicted_dates = [last_date + pd.Timedelta(days=i) for i in range(1, 6)]

predictions_df = pd.DataFrame({
    'Date': predicted_dates,
    'Predicted (XGBoost)': pred_xgb.flatten()
})

predictions_df

"""Berdasarkan model XGBoost yang telah dituning, prediksi harga Bitcoin untuk periode 20 hingga 24 Oktober 2024 menunjukkan fluktuasi harga yang bervariasi. Pada tanggal 20 Oktober, harga diperkirakan mencapai sekitar \$66,115, yang kemudian mengalami kenaikan menjadi \$67,201 pada tanggal 21 Oktober. Namun, harga mengalami penurunan pada tanggal 22 Oktober, dengan prediksi sekitar \$64,347.

Prediksi kembali menunjukkan tren pemulihan pada tanggal 23 Oktober, dengan estimasi harga \$66,573, sebelum mengalami penurunan lagi menjadi \$61,313 pada tanggal 24 Oktober. Fluktuasi harga ini mencerminkan dinamika pasar yang mungkin dipengaruhi oleh faktor eksternal, seperti berita industri atau perubahan sentimen pasar.

Secara keseluruhan, hasil prediksi ini memberikan insight penting bagi investor dan trader untuk merencanakan strategi perdagangan mereka berdasarkan proyeksi harga Bitcoin dalam jangka pendek.
"""